using System.Text.Json;
using Dapper;
using Microsoft.Data.Sqlite;
using Subdominator.Models;

namespace Subdominator.Database;

public class VulnerabilityDatabase
{
    private readonly string _connectionString;
    private readonly string _dbPath;
    
    public VulnerabilityDatabase(string databasePath = "vulnerabilities.db")
    {
        _dbPath = databasePath;
        _connectionString = $"Data Source={databasePath}";
        InitializeDatabase();
    }
    
    /// <summary>
    /// Initialize the database schema if it doesn't exist
    /// </summary>
    private void InitializeDatabase()
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        // Create the vulnerabilities table
        connection.Execute(@"
            CREATE TABLE IF NOT EXISTS Vulnerabilities (
                Id INTEGER PRIMARY KEY AUTOINCREMENT,
                Domain TEXT NOT NULL,
                Service TEXT,
                RiskLevel TEXT,
                RecordType TEXT,
                MatchLocation TEXT,
                CNames TEXT,
                ARecords TEXT,
                AAAARecords TEXT,
                IsVerified INTEGER,
                ScanDate TEXT,
                ScanId TEXT,
                IsFixed INTEGER DEFAULT 0,
                FixDate TEXT,
                Notes TEXT
            );
            
            CREATE TABLE IF NOT EXISTS Scans (
                Id TEXT PRIMARY KEY,
                Date TEXT,
                TotalDomains INTEGER,
                VulnerableDomains INTEGER,
                Settings TEXT
            );
            
            CREATE INDEX IF NOT EXISTS idx_vulnerabilities_domain ON Vulnerabilities(Domain);
            CREATE INDEX IF NOT EXISTS idx_vulnerabilities_service ON Vulnerabilities(Service);
            CREATE INDEX IF NOT EXISTS idx_vulnerabilities_scandate ON Vulnerabilities(ScanDate);
            CREATE INDEX IF NOT EXISTS idx_vulnerabilities_scanid ON Vulnerabilities(ScanId);
        ");
    }
    
    /// <summary>
    /// Save a new scan record
    /// </summary>
    public void SaveScan(string scanId, DateTime scanDate, int totalDomains, int vulnerableDomains, Options settings)
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        var settingsJson = JsonSerializer.Serialize(settings);
        
        connection.Execute(@"
            INSERT INTO Scans (Id, Date, TotalDomains, VulnerableDomains, Settings)
            VALUES (@Id, @Date, @TotalDomains, @VulnerableDomains, @Settings);
        ", new { 
            Id = scanId, 
            Date = scanDate.ToString("o"), 
            TotalDomains = totalDomains, 
            VulnerableDomains = vulnerableDomains, 
            Settings = settingsJson 
        });
    }
    
    /// <summary>
    /// Save a new vulnerability record
    /// </summary>
    public void SaveVulnerability(VulnerabilityRecord vulnerability)
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        connection.Execute(@"
            INSERT INTO Vulnerabilities 
            (Domain, Service, RiskLevel, RecordType, MatchLocation, CNames, ARecords, AAAARecords, IsVerified, ScanDate, ScanId, Notes)
            VALUES 
            (@Domain, @Service, @RiskLevel, @RecordType, @MatchLocation, @CNames, @ARecords, @AAAARecords, @IsVerified, @ScanDate, @ScanId, @Notes);
        ", vulnerability);
    }
    
    /// <summary>
    /// Get all vulnerabilities for a specific domain
    /// </summary>
    public IEnumerable<VulnerabilityRecord> GetVulnerabilitiesForDomain(string domain)
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        return connection.Query<VulnerabilityRecord>(@"
            SELECT * FROM Vulnerabilities 
            WHERE Domain = @Domain
            ORDER BY ScanDate DESC;
        ", new { Domain = domain });
    }
    
    /// <summary>
    /// Get vulnerabilities found in a specific scan
    /// </summary>
    public IEnumerable<VulnerabilityRecord> GetVulnerabilitiesForScan(string scanId)
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        return connection.Query<VulnerabilityRecord>(@"
            SELECT * FROM Vulnerabilities 
            WHERE ScanId = @ScanId;
        ", new { ScanId = scanId });
    }
    
    /// <summary>
    /// Get all vulnerabilities found between two dates
    /// </summary>
    public IEnumerable<VulnerabilityRecord> GetVulnerabilitiesBetweenDates(DateTime startDate, DateTime endDate)
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        return connection.Query<VulnerabilityRecord>(@"
            SELECT * FROM Vulnerabilities 
            WHERE ScanDate BETWEEN @StartDate AND @EndDate
            ORDER BY ScanDate DESC;
        ", new { 
            StartDate = startDate.ToString("o"), 
            EndDate = endDate.ToString("o") 
        });
    }
    
    /// <summary>
    /// Get trend data - vulnerability counts by date
    /// </summary>
    public IEnumerable<TrendDataPoint> GetVulnerabilityTrendByDate()
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        return connection.Query<TrendDataPoint>(@"
            SELECT 
                date(ScanDate) as Date,
                COUNT(*) as Count
            FROM Vulnerabilities
            GROUP BY date(ScanDate)
            ORDER BY date(ScanDate);
        ");
    }
    
    /// <summary>
    /// Get trend data - vulnerability counts by service
    /// </summary>
    public IEnumerable<TrendDataPoint> GetVulnerabilityTrendByService()
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        return connection.Query<TrendDataPoint>(@"
            SELECT 
                Service as Label,
                COUNT(*) as Count
            FROM Vulnerabilities
            GROUP BY Service
            ORDER BY COUNT(*) DESC
            LIMIT 10;
        ");
    }
    
    /// <summary>
    /// Get trend data - vulnerability counts by risk level
    /// </summary>
    public IEnumerable<TrendDataPoint> GetVulnerabilityTrendByRiskLevel()
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        return connection.Query<TrendDataPoint>(@"
            SELECT 
                RiskLevel as Label,
                COUNT(*) as Count
            FROM Vulnerabilities
            GROUP BY RiskLevel
            ORDER BY 
                CASE 
                    WHEN RiskLevel = 'Critical' THEN 1
                    WHEN RiskLevel = 'High' THEN 2
                    WHEN RiskLevel = 'Medium' THEN 3
                    WHEN RiskLevel = 'Low' THEN 4
                    ELSE 5
                END;
        ");
    }
    
    /// <summary>
    /// Mark a vulnerability as fixed
    /// </summary>
    public void MarkVulnerabilityAsFixed(int vulnerabilityId, string notes = null)
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        connection.Execute(@"
            UPDATE Vulnerabilities
            SET IsFixed = 1, FixDate = @FixDate, Notes = @Notes
            WHERE Id = @Id;
        ", new { 
            Id = vulnerabilityId, 
            FixDate = DateTime.UtcNow.ToString("o"),
            Notes = notes
        });
    }
    
    /// <summary>
    /// Get all scans
    /// </summary>
    public IEnumerable<ScanRecord> GetAllScans()
    {
        using var connection = new SqliteConnection(_connectionString);
        connection.Open();
        
        return connection.Query<ScanRecord>(@"
            SELECT * FROM Scans
            ORDER BY Date DESC;
        ");
    }
    
    /// <summary>
    /// Delete database file
    /// </summary>
    public bool ResetDatabase()
    {
        try
        {
            if (File.Exists(_dbPath))
            {
                File.Delete(_dbPath);
                InitializeDatabase();
                return true;
            }
            return false;
        }
        catch
        {
            return false;
        }
    }
}
